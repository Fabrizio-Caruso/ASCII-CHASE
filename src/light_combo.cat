#include "settings.h"

#include "character.h"
#include "item.h"
#include "ghost.h"
#include "game_text.h"

extern uint16_t points;

extern uint8_t guns;
extern uint8_t lives;

extern uint8_t level;

extern uint8_t freezeActive;
extern uint16_t freeze_count_down;


#if defined(FULL_GAME)
	extern uint8_t invincibilityActive;
	extern uint8_t confuseActive;
	extern uint8_t zombieActive;
	
	extern uint16_t invincibility_count_down;
	extern uint16_t confuse_count_down;
	extern uint16_t zombie_count_down;
	
	extern uint8_t missileBasesDestroyed;
	extern uint8_t skullsKilled;	
	
	extern uint8_t extraLife_present_on_level;
	extern uint8_t zombie_present_on_level;
#endif

extern Image DEAD_GHOST_IMAGE;

extern Character ghosts[GHOSTS_NUMBER];
extern Character bombs[BOMBS_NUMBER];
extern Character skull;

extern Character player;

extern Item powerUp;
extern Item gun;
extern Item extraPoints;


#if defined(FULL_GAME)
	extern Character *chasedEnemyPtr;
	extern Character chasingBullet;

	extern Item powerUp2;	
	
	extern Item freeze;

	extern Item invincibility;

	extern Item chase;

	extern Item super;
	extern Item extraLife;

	extern Item confuse;
	extern Item zombie;
#endif
	
#if !defined(TINY_GAME)

	void powerUpReached(Character * powerUpPtr)
	{
		ZAP_SOUND();
		#if defined(TURN_BASED)
			displayPlayer(&player);
		#endif
		powerUpPtr->_status = 0;
		displayStats();
	}

	void relocatePowerUp(Character * powerUpPtr)
	{
			powerUpPtr->_status = 1;
			
			#if defined(FULL_GAME)
			do
			{
				relocateCharacter(powerUpPtr);
			} while(innerWallReached(powerUpPtr));		
			#else
				relocateCharacter(powerUpPtr);
			#endif	
	}	
	
	#if defined(FULL_GAME)
		void _commonPowerUpEffect(void)
		{
			points+=POWER_UP_BONUS;
			decreaseGhostLevel();
			freezeActive = 1;	
			freeze_count_down += FROZEN_COUNT_DOWN;	
		}

		void powerUpEffect(void)
		{
			_commonPowerUpEffect();
			powerUp._coolDown = POWER_UP_COOL_DOWN;		
		}

		void _gunEffect(void)
		{
			guns = GUNS_NUMBER;
			#if !defined(NO_STATS)
			printGunsStats();	
			#endif
			points+=GUN_BONUS;		
		}

		void gunEffect(void)
		{
			_gunEffect();
			gun._coolDown = GUN_COOL_DOWN;	
		}
	#else

		void powerUpEffect(void)
		{
			points+=POWER_UP_BONUS;
			freezeActive = 1;	
			freeze_count_down += FROZEN_COUNT_DOWN;	
			powerUp._coolDown = POWER_UP_COOL_DOWN;		
		}

		void gunEffect(void)
		{
			guns = GUNS_NUMBER;
			#if !defined(NO_STATS)
			printGunsStats();	
			#endif
			points+=GUN_BONUS;	
			gun._coolDown = GUN_COOL_DOWN;	
		}		
	#endif

	void extraPointsEffect(void)
	{
		points+=EXTRA_POINTS+level*EXTRA_POINTS_LEVEL_INCREASE;
		extraPoints._coolDown = SECOND_EXTRA_POINTS_COOL_DOWN;//(EXTRA_POINTS_COOL_DOWN<<4); // second time is harder		
	}

	void handle_item(register Item *itemPtr)
	{
		// Manage item
		if(itemPtr->_character._status == 1)
		{	
			if(areCharctersAtSamePosition(&player, (Character *) itemPtr))
			{
				itemPtr->_effect();
				powerUpReached((Character *) itemPtr);			
			}
			else
			{
				_blink_draw(itemPtr->_character._x, itemPtr->_character._y, itemPtr->_character._imagePtr, &(itemPtr->_blink));
			}		
		}
		else if (itemPtr->_coolDown == 0)
		{
			relocatePowerUp((Character *) itemPtr);
		}
		else
		{
			--(itemPtr->_coolDown);
		}
	}

	void handle_count_down(uint8_t * activeItemFlagPtr, uint16_t * countDownPtr)
	{
		if(*activeItemFlagPtr)
		{
			if(*countDownPtr<=0)
			{
				*activeItemFlagPtr=0;
			}
			else
			{
				--(*countDownPtr);
			}
		}
	}	
	
#endif // !defined(TINY_GAME)

	
#if defined(FULL_GAME)
	void reducePowerUpsCoolDowns(void)
	{
		extraPoints._coolDown/=2;
		invincibility._coolDown/=2;
		freeze._coolDown/=2;
		TICK_SOUND();		
	}
#elif !defined(TINY_GAME)
	void reducePowerUpsCoolDowns(void)
	{
		extraPoints._coolDown/=2;
		TICK_SOUND();		
	}
#else	
#endif	


	
#if defined(FULL_GAME)
	void powerUp2Effect(void)
	{
		_commonPowerUpEffect();
		powerUp2._coolDown = POWER_UP2_COOL_DOWN;	
	}

	void _freezeEffect(void)
	{
		_commonPowerUpEffect();
		_commonPowerUpEffect();
		_commonPowerUpEffect();
	}

	void freezeEffect(void)
	{
		_freezeEffect();
		freeze._coolDown = ((uint16_t) (FREEZE_COOL_DOWN)*2);	
	}
	
	
	void extraLifeEffect(void)
	{
		++lives;
		skullsKilled=1;
		extraLife_present_on_level = 0;
		printLivesStats();		
	}

	void _invincibilityEffect(void)
	{
		invincibilityActive = 1;
		invincibility_count_down = INVINCIBILITY_COUNT_DOWN;			
	}
	
	void invincibilityEffect(void)
	{
		_invincibilityEffect();
		invincibility._coolDown = ((uint16_t) (INVINCIBILITY_COOL_DOWN)*4);
	}
	
	void superEffect(void)
	{
		_freezeEffect();
		_gunEffect();
		_invincibilityEffect();
		super._coolDown = ((uint16_t) (SUPER_COOL_DOWN)*8);
	}

	void confuseEffect(void)
	{
		confuseActive = 1;
		confuse._coolDown = SECOND_CONFUSE_COOL_DOWN;
		confuse_count_down = CONFUSE_COUNT_DOWN;
	}
	
	void zombieEffect(void)
	{
		uint8_t i;
		
		zombieActive = 1;
		missileBasesDestroyed = 1;
		zombie._coolDown = SECOND_ZOMBIE_COOL_DOWN; 
		zombie_count_down = ZOMBIE_COUNT_DOWN;
		for(i=0;i<GHOSTS_NUMBER;++i)
		{
			if(!(ghosts[i]._status))
			{
				ghosts[i]._imagePtr = &DEAD_GHOST_IMAGE;
			}
		}
	}
	
	void chaseEffect(void)
	{
		unsigned firstAliveIndex;
		
		chasingBullet._status = 1;
		chasingBullet._x = chase._character._x;
		chasingBullet._y = chase._character._y;
		
		chase._coolDown = ((uint16_t)(CHASE_COOL_DOWN)*2);
		
		firstAliveIndex = firstAlive();
		if(firstAliveIndex == GHOSTS_NUMBER)
		{
			chasedEnemyPtr = &skull;
		}
		else
		{
			chasedEnemyPtr = &ghosts[firstAliveIndex];
		}
	}
#endif
/* --------------------------------------------------------------------------------------- */ 
// 
// CROSS CHASE by Fabrizio Caruso
//
// Fabrizio_Caruso@hotmail.com
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from
// the use of this software.

// Permission is granted to anyone to use this software for non-commercial applications, 
// subject to the following restrictions:

// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software in
// a product, an acknowledgment in the product documentation would be
// appreciated but is not required.

// 2. Altered source versions must be plainly marked as such, and must not
// be misrepresented as being the original software.

// 3. This notice may not be removed or altered from any source distribution.
/* --------------------------------------------------------------------------------------- */ 
#if !defined(TINY_GAME)

#include "settings.h"

#include "skull.h"
#include "level.h"
#include "strategy.h"

extern uint8_t level;
extern uint16_t loop;

extern uint16_t skullSlowDown;
extern uint8_t skullXCountDown;
extern uint8_t skullYCountDown ;

extern uint16_t ghostLevel;

extern Character skull;
extern Character player;

extern uint8_t skullActive;

#if defined(FULL_GAME)
	extern uint8_t confuseActive;
#endif

#if defined(FULL_GAME)
uint16_t computeSkullSlowDown(void)
{
	if(loop<MAX_SKULL_LOOP)
	{
		#if defined(TURN_BASED)
			return INITIAL_SKULL_SLOWDOWN - level * 256 - ghostLevel*8;				
		#else
			return INITIAL_SKULL_SLOWDOWN - level * 256 - ghostLevel*16;		
		#endif
	}
	return SKULL_MIN_SLOWDOWN; // You must die!
}
#endif


// Redability macros
#define INACTIVITY_COUNT_DOWN_REACHED ((skullXCountDown==0) || (skullYCountDown==0))
#define GHOST_COUNT_TRIGGER_REACHED (ghostCount<=SKULL_TRIGGER)
#define BOSS_LOOP_TRIGGER_REACHED (loop>=SKULL_LOOP_TRIGGER)

#define NON_BOSS_TRIGGER_REACHED (INACTIVITY_COUNT_DOWN_REACHED || GHOST_COUNT_TRIGGER_REACHED)

#if defined(__NCURSES__)
	#define SKULL_RAND_CONDITION ((rand()&0x7fff)>skullSlowDown)
#else
	#define SKULL_RAND_CONDITION (rand()>skullSlowDown)
#endif

void handle_skull(void)
{
	if(!skullActive)
	{		
		#if defined(FULL_GAME)
		if(((!bossLevel() && NON_BOSS_TRIGGER_REACHED) || 
			 (bossLevel() && BOSS_LOOP_TRIGGER_REACHED)))
		#else
		if(NON_BOSS_TRIGGER_REACHED)
		#endif
		{
			skullActive = 1;
		}
		else
		{
			--skullXCountDown;
			--skullYCountDown;
		}
	}
	else
	{ 	
		#if defined(FULL_GAME)
			skullSlowDown = computeSkullSlowDown();
		#else
			--skullSlowDown;
		#endif

		if(SKULL_RAND_CONDITION)
		{
			TOCK_SOUND();
			deleteSkull(&skull);
			#if defined(FULL_GAME)
				if(!confuseActive || !(loop&3))
				{
					#if !defined(SIMPLE_STRATEGY)
						moveTowardCharacter(&player, &skull, 4);
					#else
						moveTowardCharacter(&player, &skull);						
					#endif
				}
			#else
				moveTowardCharacter(&skull);
			#endif
		}
		displaySkull(&skull);
		#if defined(FULL_GAME)
		if (playerKilledBy(&skull))
		#else
		if(areCharctersAtSamePosition(&skull, &player))
		#endif
		{
			playerDies();
		}
	}
}


#endif

/* --------------------------------------------------------------------------------------- */ 
// 
// CROSS CHASE by Fabrizio Caruso
//
// Fabrizio_Caruso@hotmail.com
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from
// the use of this software.

// Permission is granted to anyone to use this software for non-commercial applications, 
// subject to the following restrictions:

// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software in
// a product, an acknowledgment in the product documentation would be
// appreciated but is not required.

// 2. Altered source versions must be plainly marked as such, and must not
// be misrepresented as being the original software.

// 3. This notice may not be removed or altered from any source distribution.
/* --------------------------------------------------------------------------------------- */ 
 
#if !defined(TINY_GAME) 

#include "settings.h"
 
#include "bullet.h"
#include "level.h"
#include "game_text.h"
#include "character.h"
#include "item.h"
#include "ghost.h"
#include "strategy.h"



extern uint16_t points;
extern uint8_t ghostCount;
extern Character ghosts[GHOSTS_NUMBER];
#if !defined(NO_DEAD_GHOSTS)
extern Image DEAD_GHOST_IMAGE;
#else
extern Image SKULL_IMAGE;	
#endif
extern uint8_t level;

extern Item extraPoints;

extern Character skull;
extern uint8_t skullActive;
extern uint8_t playerFire;
extern uint8_t guns;
extern uint8_t playerDirection;
extern uint8_t bulletDirection;

extern Character bullet;
extern Character player;


	
#if defined(FULL_GAME) 
	extern Item freeze;
	extern Item extraLife;
	extern Item invincibility;
	
	extern Character chasingBullet;
	
	extern Character leftHorizontalMissile;
	extern Character rightHorizontalMissile;
	extern uint8_t rockets_x[ROCKETS_NUMBER];
	extern Character rockets[ROCKETS_NUMBER];
	extern uint8_t dead_rockets;
	extern uint8_t missileBasesDestroyed;

	extern Character *chasedEnemyPtr;	
#endif

#if defined(FULL_GAME)
	void handle_chasing_bullet(void)
	{
		if(chasingBullet._status)
		{
			deleteChasingBullet(&chasingBullet);
			#if !defined(SIMPLE_STRATEGY)
				moveTowardCharacter(chasedEnemyPtr, &chasingBullet, 4);
			#else
				moveTowardCharacter(chasedEnemyPtr, &chasingBullet);				
			#endif
			displayChasingBullet(&chasingBullet);
			checkBullet(&chasingBullet);
		}	
	}
#endif
	
void handle_bullet(void)
{
	// Check if player has fired the gun
	if(playerFire && bullet._status==0 && guns>0)
	{
		SHOOT_SOUND();
		--guns;
		#if !defined(NO_STATS)
		printGunsStats();
		#endif
		bulletDirection = playerDirection;
		bullet._status = 1;
		bullet._x = player._x; 
		bullet._y = player._y;		
		playerFire = 0;	
	}
	
	// Move bullet if fired
	if(bullet._status==1)
	{
		moveBullet(&bullet);
		checkBullet(&bullet);
	}
}


void checkBullet(Character *bulletPtr)
{
	checkBulletVsSkull(bulletPtr);
	checkBulletVsGhosts(bulletPtr);
}

void checkBulletVsGhost(Character * bulletPtr,
						Character * ghostPtr)
{
	if(ghostPtr->_status && areCharctersAtSamePosition(bulletPtr, ghostPtr))
	{
		points+=GHOST_VS_MISSILE;
		ghostDies(ghostPtr);
		
		bulletPtr->_status=0;
	}
}
	
void checkBulletVsGhosts(Character * bulletPtr)
{
	uint8_t i = 0;
	for(;i<GHOSTS_NUMBER;++i)
	{
		checkBulletVsGhost(bulletPtr, &ghosts[i]);
	};
}

void checkBulletVsSkull(register Character *bulletPtr)
{
	if(skullActive && skull._status &&
	   areCharctersAtSamePosition(bulletPtr, &skull))
	{
		PING_SOUND();
		bulletPtr->_status=0;
		#if defined(FULL_GAME)
		decreaseGhostLevel();
		#endif
		reducePowerUpsCoolDowns();
		
		if(!(--skull._status))
		{
			deleteSkull(&skull);
			EXPLOSION_SOUND();
			points+=SKULL_POINTS;
			displayStats();
		}
	}	
}


void _moveBullet(register Character *bulletPtr)
{
	deleteBullet(bulletPtr);
	switch(bulletDirection)
	{
		case RIGHT:
			++bulletPtr->_x;
		break;
		case DOWN:
			++bulletPtr->_y;
		break;
		case UP:
			--bulletPtr->_y;
		break;
		case LEFT:
			--bulletPtr->_x;
		break;
	}	
}


#if defined(FULL_GAME)
	void destroyHorizontalMissile(Character * horizontalMissilePtr)
	{
		horizontalMissilePtr->_status = 0;
		EXPLOSION_SOUND();
		deleteHorizontalMissile(horizontalMissilePtr);
		points+=HORIZONTAL_MISSILE_BONUS;
		displayStats();				
		++dead_rockets;
		reducePowerUpsCoolDowns();		
	}
#endif


#if defined(CC65_GOTO)
	#define GOTO_DESTROY() \
		asm("jmp %g", _destroy); 
#else
	#define GOTO_DESTROY() \
		goto _destroy; 
#endif

void moveBullet(register Character * bulletPtr)
{
	_moveBullet(bulletPtr);
	if(wallReached(bulletPtr) && bulletPtr->_status)
	{
		bulletPtr->_status=0;
		
		deleteBullet(bulletPtr);
		#if defined(FULL_GAME)
			DRAW_BROKEN_BRICK(bulletPtr->_x, bulletPtr->_y);
			
			if(oneMissileLevel())
			{
				if(bulletPtr->_x==XSize-1 && bulletPtr->_y==YSize/2 && rightHorizontalMissile._status)
				{
					GOTO_DESTROY();
					// goto _destroy; //destroyHorizontalMissile(&rightHorizontalMissile);
				}
			}				
			else if(missileLevel() || bossLevel())
			{
				if(bulletPtr->_x==XSize-1 && bulletPtr->_y==HORIZONTAL_MISSILE_OFFSET && rightHorizontalMissile._status)
				{
					_destroy: destroyHorizontalMissile(&rightHorizontalMissile);	
				}
				else if(bulletPtr->_x==0 && bulletPtr->_y==YSize-1-HORIZONTAL_MISSILE_OFFSET && leftHorizontalMissile._status)
				{
					destroyHorizontalMissile(&leftHorizontalMissile);	
				}
			}
			if((rocketLevel() || bossLevel()) && bulletPtr->_y==YSize-1)
			{
				uint8_t i;
				for(i=0;i<ROCKETS_NUMBER;++i)
				{
					if(bulletPtr->_x==rockets_x[i] && rockets[i]._status)
					{
						rockets[i]._status = 0;
						++dead_rockets;
						EXPLOSION_SOUND();
						deleteRocket(&rockets[i]);
						points+=VERTICAL_MISSILE_BONUS;
						displayStats();		
					}
				}
			}			
		#endif		
	}
	else
	{
		displayBullet(bulletPtr);
	}
}

#endif

